### 01. Биометричен контрол. Цифров сертификат. Бейсов анализ. Бейсов класификатор. Мрежов сървър. Отворено прокси. Отворен препредавател.

В наши дни, мрежовата сигурност е от съществено значение, поради усилената дигитализация и нарастващата зависимост от цифрова комуникация, съхранение на данни и прочие. Мрежова инфраструктура има множество компоненти които трябва да се подсигурят, а също така и множество теми и въпроси, които може да се разгледат, част от които са: биометричен контрол, цифрови сертификати, бейсов класификатор, мрежови сървър, отворено прокси и отворен предавател.

#### Автентикация

Автентикацията е процес за потвърждаване самоличността на потребител, устройство или система. Този процес е изключително важна част от сигурността на повечето системи и подсигурява че само удостоверени обекти ще достъпят защитени ресурси.

Има няколко вида методи за автентикация, които можем да групираме в три основни категории:

- Фактори за знание ("Нещо което знаете")
  - Парола или Персонален Идентификационен Номер (ПИН)
  - Отговори на "тайни въпроси"
- Фактори за притежание ("Нещо което имате")
  - Хардуерен или софтуерен токен
  - SSH Ключове - двойка криптографски ключове, ползвани да удостоверят клиент пред сървър. Частния ключ се държи от клиента (и трябва да е добре подсигурен), докато публичния ключ се държи от сървъра.
- Присъщи фактори ("Нещо което си") - Този вид удостоверяване включва биометрични данни, физически или поведенчески характеристики уникални за потребителя.
  - Пръстов отпечатък - Това е един от най-разпространените методи за биометрична идентификация. Пръстовите отпечатъци на всеки човек са уникални и много устройства вече имат вградени скенери за пръстови отпечатъци.
  - Сканиране на ретината или ириса - Този метод на удостоверяване използва уникалните модели в ретината или ириса на индивида за идентификация. Той е изключително сигурен, тъй като е силно устойчив на дуплициране, но изисква специално оборудване и може да бъде натрапчив.

Също така си струва да се отбележи, че има и други методи за удостоверяване, въпреки че те се използват по-рядко:

- Фактори на местоположението - Това може да се основава на физическото местоположение на потребителя, определено от IP адрес, GPS и др.

Всеки от тези методи има свойте силни и слаби страни. Често множество методи се комбинират в система за многофакторно удостоверяване (MFA), за повишаване на сигурността. Например банкоматът използва двуфакторно удостоверяване (2FA): трябва да имате картата си за банкомат (нещо, което имате) и да знаете вашия ПИН (нещо, което знаете), за да изтеглите пари.

#### Биометричен Контрол

Биометричния контрол (категорията присъщи фактори) е модерен метод за автентикация, които добавя възможността да удостоверим даден потребител, базирано на неговите биометрични данни, било то физически или поведенчески, като например пръстов отпечатък, сканиране на ретина или ирис, лицево разпознаване, гласово разпознаване и прочие.

Механизма на действие на този вид защита зависи от конкретната имплементация, но общо можем да го разгледаме чрез тези 4 фази: Записване, Съхранение, Проверка за съвпадение и Решение.

- **Записване:** По време на тази фаза, системата записва биометричните данни на потребителя и ги обработва в биометричен шаблон.
- **Съхранение:** В тази фаза данните се съхраняват в база от данни за бъдещи сравнения, като схемата на данните е ясно дефинирана.
- **Проверка за съвпадение:** В тази фаза системата взема текущи биометрични данни за потребителя и проверява идентичността му като го сравнява със съхранения в базата от данни шаблон за този конкретен потребител.
- **Решение:** Системата взема решение, обикновено на базата на това до какъв процент данните съвпадат, има зададен праг на допустимост и автентикира или отхвърля потребителя.

В контекста на мрежова сигурност, биометричния контрол подобрява сигурността чрез добавяне на ниво на проверка на потребителя, което е трудно за подправяне, повишавайки целостта и поверителността на една система.

#### Цифров Сертификат

Цифров сертификат (категория фактори за притежание) е криптографски документ ползван за доказване на дигитална идентичност. Тази идентичност може да бъде човек, компютър, компания, данни и прочие. Тези сертификати се ползват в множество протоколи за сигурност с идеята да подсигурят че тези данни се обменят през мрежата в защитен вид.

Цифровия сертификат съдържа в себе си информация относно ключа (публичния ключ), самоличността на собственика и цифровия подпис на сертифициращ орган (Certificate Authority; CA), който проверява и гарантира за автентичността на сертификата. Дигиталните сертификати оперират на т.нар. инфраструктура с публичен ключ (Public Key Infrastructure; PKI), която включва роли, политики, хардуер, софтуер и стандарти работещи заедно, за да осигурят рамка за сигурни комуникации и цифрови подписи.

Получаването и използването на цифров сертификат включва няколко стъпки: заявка за сертификат, проверка и подписване, внедряване и защитена комуникация.

- Публичен ключ и собственост: При криптография с публичен ключ, всеки обект е двойка от публичен ключ и частен ключ. Публичния ключ се споделя свободно и може да се ползва от всеки за да криптира съобщение. Частния ключ се държи в тайна и се ползва за декриптиране на съобщение. Цифровия сертификат връзва публичния ключ към обекта който го притежава. Това гарантира, че когато някой използва публичния ключ, за да изпрати защитено съобщение

Цифровите сертификати са от особено значение за електронната търговия, онлайн банкирането и всеки сценарий, при които сигурността на данните и удостоверяването са приоритет.

#### Бейсов Анализ и Бейсов класификатор

Бейсов Анализ е статистически метод, базиран на "Теоремата на Бейс", (кръстена на математика Томас Бейс) която теорема се използва в теорията на вероятностите за изчисляване на вероятността за настъпване на дадено събитие, след като вече е известна част от информацията за него.

Бейсов класификатор е вид класифициращ алгоритам базиран на "Теоремата на Бейс", който прогнозира вероятностите за членство за всеки клас, като например вероятността даден запис или точка от данни да принадлежи към определен клас. Класът с най-висока вероятност се счита за най-вероятен клас.

- При машинно обучение се ползва найвен бейсов класификатор, който работи, като изчислява вероятностите всеки атрибут на точка от данни да принадлежи към всеки клас и взема произведението на тези вероятности, за да изчисли вероятността цялата точка от данни да принадлежи към класа. След това точката от данни се присвоява на класа с най-висока вероятност.
- В частност при мрежовата сигурност, бейсов класификатор и по конкретно найвен бейсов класификатор се прилага в системи за откриване на прониквания (intrusion detection systems) и филтриране на спам (spam filtering)

И в двата случая бейсовия класификатор предоставя вероятностна рамка за вземане на решения въз основа на доказателства, налични в данните. Важно е да запомним, че ефективността на бейсовия класификатор, както при всички модели за машинно обучение така и в мрежовата сигурност, зависи от качеството и обхвата на данните за обучение. Той също така изисква текущи актуализации, за да остане ефективен, когато се появят нови заплахи и спам техники.

#### Мрежов сървър

Мрежови сървър (софтуер) е програма, която е проектирана да обработва заявки и да доставя данни на други програми (клиенти) през локална мрежа или интернет. Сървърният софтуер позволява на сървъра да предоставя услуги, като обслужване на уебсайтове, хостване на бази данни, споделяне на файлове или изпращане на имейли. Този софтуер може да работи както на специална сървърна машина така и на обикновен компютър, настроен да обработва заявките.

Има различни видове мрежови сървъри:

- Уеб сървър - Това са приложения, които предоставят ресурси на клиенти, най-често уеб браузъри, изискващи уеб страници. Например: Apache HTTP Server, Nginx и IIS са високоспособни уеб сървъри, предоставящи функционалност като SSL/TLS криптиране, виртуален хостинг (хостване на множество уебсайтове на един сървър), балансиране на натоварването и прочие.
- Сървър на база от данни - Тези сървъри съхраняват, извличат и управляват данни в структуриран формат, като същевременно отговарят на заявки за свойте данни на други софтуерни програми. Примерите включват MSSQL, MySQL, MongoDB, PostgreSQL, Oracle Database
- Файлови сървъри - Управляват и разпределят достъпа до файлове и директории в мрежа. Те обработват заявки за достъп, четене, писане и изтриване на файлове. Примерите включват:
  - Server Message Block (SMB) - Протоколът за споделяне на файлове по подразбиране за операционна система Windows.
- Пощенски сървър - Отговаря за изпращането, получаването и съхраняването на имейл съобщения. Примерите включват:
  - Microsoft Exchange - Пощенски сървър, софтуер за календари и мениджър на контакти, разработени от Microsoft.

#### Прокси

Прокси сървърът като цяло е междинен сървър, който седи между клиентските устройства (като компютри или мобилни телефони) и целевите сървъри. Това означава че всяка заявка от клиент до сървър и обратно минава първо през прокси сървър.

Има няколко вида проксита, включително:

- Отворено Прокси (Open Proxy) - тип прокси сървър, който е публично достъпен за всеки интернет потребител. Въпреки че могат да се използват за поддържане на анонимност или заобикаляне на гео ограничения, те често се използват за незаконни действия и като такива често попадат в черния списък на много уебсайтове и интернет доставчици.
- Прокси за препращане (Forward Proxy) - тези проксита се използват като посредник за клиенти, които правят заявки към сървъри. Тоест клиента прави заявка първо до проксито, което прави заявка от негово име през интернет до сървъра. Тези проксита помагат за анонимност на потребителя.
- Обратно Прокси (Reverse Proxy) - тези проксита се използват като посредник за сървъри, които слушат за заявки от интернет. Клиентът прави заявка към сървъра, но обратно прокси прихваща заявката и я обработва, преди да достигне до сървъра. Тези проксита помагат за балансиране на натоварване, имплементиране на защити от атаки и прочие. Например Nginx може да се конфигурира като обратно прокси и да посрещне заявка от интернет преди да я разпредели към сървър.

#### Отворен Препредавател. (Open ReTransmitter)

Предавател, който е отворен за комуникация и приемане на сигнали от външни източници, можем да се отнасяме към устройство или система, което може да комуникира с други устройства или мрежи и да приема сигнали от тях.

Такъв тип предавател може да бъде използван в различни области и приложения, като:

- **Радиокомуникации:** Например радиостанции, които са отворени за приемане на радиосигнали от други източници и предаване на сигналите на определена честота към други устройства или мрежи.
- **Мрежови комуникации:** Например маршрутизатори или суичове, които са отворени за получаване и предаване на мрежови пакети от други устройства или мрежи.
- **IoT (Интернет на нещата):** Устройства в Интернет на нещата, които могат да комуникират и приемат данни от други IoT устройства или облачни системи.

### 02. Дефиниция на понятието информационна архитектура. Информационни нужди на потребителите, типове потребителско поведение при търсене на информация. Основни компоненти на информационната архитектура. Организационни системи. Системи за етикетиране. Навигационни системи. Системи за търсене. Невидими информационни компоненти.

Информационна архитектура (IA) е наука и изкуство по структуриране, организиране и етикетиране на съдържание така че то да бъде подредено и ефективно.

Главната цел на (IA) в рамките на една уеб платформа е да помогне на потребителите да намерят информацията от която се нуждаят. Тя обхваща организацията на данни, разработването на навигационни системи, разработването на системи за етикетиране и системи за търсене, за да се подкрепи ефективната навигация, откриването и разбирането на информация от страна на потребителите на системата. Тя включва създаването на план, който гарантира, че информацията е логично организирана, лесно достъпна и интуитивно разбираема.

Архитекти на информацията се стремят да създадат съгласувани структури, насочени към потребителите, които подобряват потребителския опит и позволяват на потребителите да откриват, интерпретират и взаимодействат с информацията ефективно.

#### Информационни нужди на потребителите:

Разбирането на информационните нужди на потребителите е от съществено значение за проектирането на ефективна архитектура на информацията. Потребителите имат разнообразни изисквания и очаквания, когато търсят информация. Някои общи информационни нужди включват получаване на конкретни данни, изследване на нови знания, решаване на проблеми, вземане на решения или изпълнение на задачи. Потребителските изследвания, като интервюта с потребители, анкети и тестове за използваемост, помагат за идентифициране и приоритизиране на тези информационни нужди. Като получат информация за целите, мотивациите и очакванията на потребителите, архитекти на информацията могат да проектират архитектури, които отговарят на техните изисквания.

Потребителите проявяват различни поведенчески модели при търсене на информация, и архитектите на информацията трябва да вземат тези поведения под внимание при проектиране на информационни системи. Някои общи поведения на потребителите включват:

- **Разглеждане (browsing):** Потребителите се ангажират с експериментални дейности, сканирайки наличната информация, за да получат общо представление, преди да се фокусират върху конкретни детайли. Проектирането на интуитивни навигационни системи и осигуряването на ясни пътища за разглеждане е от съществено значение, за да се подкрепи разглеждащото поведение.

- **Търсене (Known-item search behavior):** Потребителите знаят точно какво искат да намерят – обикновено документ или специфичен факт. Внедряването на надеждни механизми за търсене, които помагат намирането на конкретна информация и които връщат точни резултати, е от съществено значение. Включването на функции като автоматично довършване, филтри и напреднали опции за търсене подобрява потребителското изживяване при търсене.

- **Заявка (querying):** Потребителите формулират конкретни заявки или искания, за да получат желаната информация. Архитектурата трябва да подкрепя взаимодействията, базирани на заявки, като осигурява разбиране и ефективно реагиране на системата към заявките на потребителя.

- **Филтриране:** Потребителите прилагат филтри, за да ограничат информацията въз основа на определени критерии, като например дата, категория или релевантност. Включването на механизми за филтриране улеснява потребителите при прецизиране на техните резултати от търсене и намиране на информация, която е в съответствие с техните изисквания.

#### Основни компоненти на информационна архитектура

- **Организационни системи:** Тези системи установяват йерархията, групирането и взаимоотношенията между информационните елементи. Организационните системи определят начина, по който информацията се класифицира, групира и представя, гарантирайки логични и смислени връзки. Концепцията за организационните системи се върти около подреждането и структурата на информационните елементи в рамките на система. Тя включва установяване на йерархии, категоризации и взаимоотношения между различните компоненти.

- **Системи за етикетиране:** Системите за етикетиране осигуряват ясни и последователни конвенции за именуване на информационните елементи, което помага на потребителите да разберат тяхната цел и контекст. Ефективното етикетиране подобрява навигацията, търсенето и общото разбиране. То също така трябва да съответства с изградените ментални модели и очаквания на потребителите.

- **Системи за навигация:** Системите за навигация позволяват на потребителите да се движат в информационното пространство, насочвайки ги към желаната информация. Съществуват различни модели на навигация, като йерархична, фасетна и контекстуална навигация. Интуитивните системи за навигация, като йерархични менюта, "breadcrumbs" (пътеки) и карти на сайтове, подобряват потребителското изживяване.

- **Системи за търсене:** Системите за търсене позволяват на потребителите да намерят конкретна информация, като въвеждат заявки или ключови думи. Препоръчва се включването на функции като автоматично довършване на заявките, ранжиране на резултатите по релевантност и опции за разширено търсене, за да се подобри изживяването при търсене.

#### Невидими компоненти на информационната архитектура:

Невидимите компоненти на информацията са критични елементи на информационната архитектура, които може да не са директно видими за потребителите, но играят важна роля в организирането и управлението на информацията ефективно. Тези компоненти осигуряват основна структура и контекст на видимите елементи на информацията, улеснявайки извличането и разбирането на информацията.

Ето типовете невидими компоненти на информацията заедно с техните дефиниции:

- **Метаданни:** те се отнасят до описателна информация за съдържанието, контекста и характеристиките на елементите на информацията. Те предоставят допълнителен контекст и позволяват ефективното организиране, откриване и извличане на информацията. Метаданните включват атрибути като заглавие, автор, дата, маркери, категории и ключови думи. Чрез включването на метаданни информационните архитекти могат да подобрят възможностите за търсене, да осигурят опции за филтриране и да подобрят общата намираемост на информацията.
- **Таксономии:** йерархични схеми за категоризиране, които класифицират и организират информацията въз основа на предварително определени категории и взаимоотношения. Те предоставят систематичен и структуриран подход към организирането на елементите на информацията. Таксономиите могат да бъдат широки или стеснени, в зависимост от необходимия степен на детайлност. Чрез използването на таксономии информационните архитекти могат да гарантират последователна класификация, да подобрят навигацията и да повишат способността на потребителя да разглежда и изследва съдържанието в рамките на добре дефинирана структура.
- **Информационни връзки:** определят връзките и асоциациите между различни елементи на информацията. Тези връзки могат да бъдат явни или неявни и могат да включват различни типове като родител-дете, брат-сестра или асоциативни връзки. Разбирането и представянето на информационните връзки позволява на потребителите да навигират през свързаното съдържание, да открият съответна информация и да установят контекстуални връзки между различни части на информацията.
- **Модели на данни:** представят основната структура и организация на данните в рамките на информационна система. Те дефинират същностите, атрибутите и връзките между елементите на данните. Моделите на данните предоставят основа за организирането и съхраняването на информацията по структуриран и ефективен начин. Чрез проектиране на подходящи модели на данни информационните архитекти гарантират цялост на данните, подкрепят сложни заявки и анализи и позволяват безпроблемна интеграция на различни източници на информация.
- **Връзки на съдържанието:** фокусират се върху връзките между части на съдържанието в рамките на информационна система. Тези връзки могат да включват връзки, препратки, цитати и кръстосани препратки между свързани елементи на информацията. Връзките на съдържанието улесняват изследването на съдържанието, кръстосаното препращане и контекстуалното разбиране, като позволяват на потребителите да навигират между взаимосвързаните елементи на информацията.
- **Контекстуална информация:** обхваща ситуационните и околни фактори, които влияят върху разбирането и тълкуването на информацията. Това може да включва фактори като потребителски профили, потребителски предпочитания, местоположение, тип на устройството и време. Запознаването с контекстуалната информация позволява на информационните архитекти да персонализират представянето и доставката на информацията спрямо специфичните потребности на потребителите, подобрявайки потребителското изживяване и актуалността на предоставената информация.

### 05. Oбектно ориентираното програмиране – общ преглед. Работата с изключения и входно изходните операции.

Обектно-ориентираното програмиране (ООП) е парадигма, която се базира на идеята за обекти, всеки от които съдържа данни и поведение.

Едни от най-използваните програмни езици (като C++, C#, Java и Python) са много-парадигмени и поддържат обектно-ориентирано програмиране. Има множество ООП езици, но най-известните са базирани върху идеята за класове (class-based).

#### Класово-базиран и прототипно базиран език

При класово-базираните езици като (C++, C# и Java), класа е шаблон от който се създава обект, а обекта е инстанция на даден клас. Съответно класа (шаблона) дефинира полетата и методите които ще бъдат част от този клас. Наследяването е имплементирано чрез йерархия от класове, тоест дефинираме супер клас (още наричан базов клас) и след това дефинираме произволен брой подкласове, които наследяват полета и методи от този суперклас. След това можем да създадем допълнителни подкласове, които наследяват от тези подкласове и т.н., образувайки дървовидна структура.

При прототипно-базираните езици като (JavaScript), обектите са основните актьори. Няма класове. Вместо това обектите могат да наследяват от други обекти, този процес е известен като прототипно наследяване. Когато създаваме нов обект, ние просто клонираме съществуващ обект (който става прототип на новия обект) и след това модифицираме новия обект според нуждите. Когато даден обект получи заявка за свойство (property), което не притежава, неговият прототип ще бъде търсен за свойството, след това прототипът на прототипа и така нататък, докато или свойството бъде намерено, или бъде достигнат краят на веригата от прототипи.

##### Класове и обекти

При традиционното ОПП базирано на класове, програмата се разделя на класове, които служат като шаблони за създаване на обекти, като всеки обект е инстанция на даден клас. Всеки обект създаден от клас притежава полета (променливи от тип предварително деклариран в класа, които съхраняват данни) и методи (процедури или функций, които оперират върху тези данни). В ООП, компютърните програми се изграждат от обекти, които взаимодействат помежду си.

#### 4 Принципа на ООП

Има 4 основни принципа, паричани още стълбове, които са заложени в ООП. Те са абстракция, енкапсулация, наследяване и полиморфизъм.

**Абстракция**
Това е похват за скриване на детайли по имплементацията, с цел да насочи вниманието към това, което обектът прави, вместо как го прави. Например когато караме кола не е нужно да разбираме сложността на всички вътрешни работи на машината, за да можете да я управляваме. Това, от което се нуждаем, е да знаем какви операции можем да извършим с нея (като ускоряване, спиране, завой и т.н.). Сложните подробности като как работи двигателят, как работи спирачната система, са абстрахирани далеч от водача.

В известен смисъл в програмирането един клас не трябва да знае вътрешните детайли на друг, за да го използва. Единственото което трябва да познава са неговите интерфейси. Абстракция се постига използвайки интерфейс или абстрактен клас, т.е., ние изразяваме намерението на класа, а не действителното изпълнение, което от своя страна прави този абстрактен клас или интерфейс лесен за ползване от друг клас.

**Енкапсулация**
Енкапсулацията е механизъм за скриване на вътрешното състояние и данни на обект чрез ограничаване на достъпа. Директния достъп до данните са забранени, вместо това се предоставят операции, които позволяват поведението на обекта да бъде контролирано, без да се разкрива неговата вътрешна структура или състояние. Това обикновено се постига чрез използване на модификатори за достъп (като public, private, protected) в дефиницията на класа на обекта.

**Наследяване**
Наследяването е начин за формиране на нови класове, като се използват класове, които вече са дефинирани. Новите класове, известни като производни класове (derived classes), поемат (или наследяват) атрибути и поведение на съществуващите класове, които се наричат ​​базови класове. Това е мощен начин за постигане на преизползваем код.

Езиците, които поддържат класове, почти винаги поддържат наследяване. Това позволява класовете да бъдат подредени в йерархия, която представлява връзка между класове от тип "is-a". Например `class Employee` ще наследи от `class Person` всички полета и методи, достъпни за родителския клас, а те ще се появяват в дъщерния клас със същите имена `firstName`, `lastName` и `getFullName()`. Сега дъщерния клас може вече допълнително да добави нови полета и методи като например `salary` и `getSalary()`. Също така подкласовете могат да презапишат методите (override), дефинирани от суперкласовете.

Някой езици поддържат множественото наследяване (C++, Python) което позволява по-сложно поведение.

- Множественото наследяване позволява на дъщерен клас наследи няколко родителски класа, т.е. ако имаме набор от поведения, които могат логически да бъдат разделени в различни родителски класове, можем да конструираме подклас, който наследява от всички тях, което дори улеснява изграждане на по-сложни структури и поведения и дава по-организирана архитектура.
- Въпреки това, множественото наследяване може да усложни заменянето на методи `ovverides`, например когато два базови класа имплементират метод с едно и също име възниква следния проблем - клас B и C наследяват от A, а клас D наследява и от B и C. Ако има метод "m" в A, който B и C са заменили, а D не го заменя, тогава коя версия на метода D наследява, този на B или този на C? Това често се нарича "Проблема на Диаманта"
- Струва си да се отбележи, че при дизайна на много езици (Java и C#) е взето решение да се избегне сложността на множественото наследяване, като не го включват в езика. Вместо това те използват интерфейси, за да получат някои от предимствата без усложнения. Други езици, като Python позволяват множествено наследяване, но осигуряват механизми като Method Resolution Order (MRO) за разрешаване на проблема с диаманта.

**Полиморфизъм**
Полиморфизъм (от Гръцки - множество форми) позволява на обект да има много значения или форми и да реагират различно при извикване на един и същ метод. Полиморфизмът се постига чрез презаписване (override) и претоварване на методи. (overload) и съответно има два вида полиморфизъм.

- **Статичен** - Постига се чрез претоварване на матод и претоварване на оператора. Определя се по време на компилиране.
- **Динамичен** - Постига се чрез замяна на метод (override). Определя се по време на изпълнение.

Базов пример за динамичен полиморфизъм е например ако имаме `class Animal` и два дъщерни класа `Dog` и `Cat` които презаписват (override) `make_sound()` метода на родителския клас ние ще имаме различно поведение при извикването на този метод в дъщерните класове, единият метод ще връща _"Woof!"_, а другия _"Meow!"_

Той позволява на обекти от различни типове да бъдат третирани еднакво, осигурявайки гъвкавост и разширяемост в дизайна. Полиморфизмът се постига често чрез презаписване (override) и претоварване на методи. (overload)

#### Работа с изключения

Изключение е събитие, което възниква по време на изпълнение на програма и нарушава нормалния поток от инструкции. Обработката на изключения е механизъм за обработка на грешки по време на изпълнение, така че да може да се поддържа нормалният поток на програмата, т.е., механизма позволява на програмистите да обработват грешки повреме на изпълнение (runtime errors), предотвратявайки срив на програмата.

Изключенията могат да се обработват с помощта на `try-catch` блок, например:

```csharp
try
{
    // Code that could potentially throw an exception
}
catch (Exception e)
{
    // Code to handle the exception
    Console.WriteLine(e.Message);
}
finally
{
    // Code to be executed regardless of an exception occurring or not
}
```

#### Работа с входно/изходни данни

Входно/изходните (I/O) операции включват взаимодействие с файлове, мрежа, конзоли или всякакви други входно/изходни източници или устройства. Входните операции включват четене на данни от устройства, а изходните писане на данни от програмата към тези устройства.

Двете основни концепций които формират входните и изходните операции са:

- Буфериране и потоци
- Асинхронни входно/изходни операции

**Буфериране и потоци**
За да се справят ефективно с I/O операциите, много среди за програмиране използват концепции като буфериране и потоци.

- Буферът е област от паметта, използвана за временно задържане на данни, докато се прехвърлят между две места.
- Потоците абстрахират детайлите на входа/изхода, позволявайки на програмистите да четат от или да пишат в различни източници или дестинации, използвайки общ набор от функции или методи. Потокът може да се разглежда като конвейерна лента с елементи от данни, движещи се по него.

**Асинхронни I/O**
Асинхронните I/O операции позволяват на програмата да инициира I/O операция и след това да продължи с други задачи, без да чака I/O операцията да завърши. След като I/O операцията приключи, програмата се уведомява, за да може да обработи данните или да обработи резултата.

- Асинхронният I/O е особено важен при програмирането на потребителския интерфейс (за предотвратяване на "замръзване" на потребителския интерфейс по време на дълги операции) и в сървърното програмиране (за обработка на много заявки едновременно).

### 06. Многонишковото програмиране в Java - цикъл на живот и възможности за синхронизация на нишки. Основни принципи на конкурентното програмиране и разпределението на ресурсите между нишки.

Многонишковото програмиране в Java е способността да изпълняваме множество нишки върху централния процесор едновременно. При многонишковото програмиране, всяка нишка споделя ресурси на едно или повече ядра, като много нишки се създават от един процес.

Нишка означава нишка за изпълнение (thread of execution) в програмата. JVM позволява на една програма да има множество нишки, работещи едновременно. Всяка нишка има приоритет. Нишките с по-висок приоритет се изпълняват с предимство пред нишките с по-нисък приоритет. Всяка нишка може или не може също да бъде маркирана като демон. Когато кодът, изпълняван в някоя нишка, създава нов Thread object, приоритетът на новата нишка първоначално е равен на приоритета на създаващата нишка и е демон нишка тогава и само ако създаващата нишка е демон.

Когато се стартира JVM, обикновенно има една нишка, която не е демон и която обикновено извиква метода main. След това тя продължава да изпълнява нишки докато настъпи някое от следните условия:
- Извикан е `exit` метода на `class Runtime`.
- Всички нишки, които не са демон нишки, са мъртви.

#### Жизнен цикъл.
В Java нишките имат добре дефиниран жизнен цикъл, който се състои от различни състояния:

- **New** - Когато създаваме нова инстанция на `Thread class`, създаваме нова нишка. Това състояние представлява нишка, която е създадена, но все още не е стартирана.
- **Active** - Когато метода `start()` бъде извикан върху нишка, тя се премества от `new` в `active` състояние. Активното състояние съдържа две състояния в себе си: **runnable** и **running**
    - **Runnable** - Когато метода `start()` бъде извикан върху нишка, тя се премества в състояние за изпълнение. В това състояние нишката може действително да се изпълнява (ако системата е разпределила CPU време за нея) или може да е готова за изпълнение и чака да получи CPU време. JVM трупа нишките за изпълнение в басейн `thread pool` и планира позволеното време за изпълнение на всяка една нишка въз остова на `thread scheduling`.
    - **Running** - Ако процесорът е избрал нишката от `thread pool` със нишки готови за изпълнение **runnable**, то нишката преминава в статус на изпълнение **running**. Само една нишка може да бъде изпълнявана във дадено ядро на централния процесор. Това е състоянието, в което се случва действителното изпълнение и кодът на нишката се изпълнява ред по ред.
- **Blocked** - Нишката влиза в това състояние, когато временно не може да продължи с изпълнението си, защото чака ресурс да стане достъпен или поради други условия, като изчакване за завършване на операции за вход/изход, изчакване на заключване (lock) или изчакване на условие в синхронизиран блок. Когато блокираното състояние бъде премахнато, нишката се връща обратно в състояние на изпълнение.
- **Waiting State** - Нишката влиза в това състояние, когато викнем методите `wait()`, `join()` or `park()` върху нея. Нишката остава в това състояние, докато не бъде уведомена, прекъсната или не мине определено време, зададено в параметрите на методите. Нишката не може да се върне в изпълнимо състояние без външна намеса или ако е зададено време, докато то не изтече.
- **Terminated** - Нишката влиза в това състояние, когато нейният `run()` метод е завършил, независимо дали е завършил естествено след приключване на работата си или е бил внезапно прекъснат по някаква причина. След като нишката бъде прекратена, тя не може да бъде стартирана отново.

#### Възможности за синхронизация на нишки
Синхронизацията на нишките представлява възможността да се контролира достъпа на нишките до споделени ресурси, гарантирайки тяхната координация и това, че само една нишка може да достъпи даден ресурс за дадено време. Синхронизацията на нишки ни осигурява цялостност, интегритет и консистенстност на данните и ни позволява да избегнем състезателни условия (race conditions) и ситуаций на безизходица (deadlocks)

Синхронизацията решава проблемите с конкурентния достъп до общи ресурси, като прави достъпа до тях последователен. Тя предизвиква подреждане на заявките в последователност по такъв начин, така че когато една заявка се изпълнява, всички останали я чакат и се изпълняват едва след като тя приключи. Този процес съвсем не е автоматичен и се задава от програмиста чрез средствата за синхронизация.

- **Синхронизирани методи:** Запазената дума **synchronized**, зададена при декларацията на метод предизвиква синхронизиране на изпълнението на този метод по обекта, на който той принадлежи, а при статични методи – по класа, на който той принадлежи. Синхронизацията на програмен код по някакъв обект предизвиква заключване на този обект при започване на изпълнението на синхронизирания код и отключване на обекта при завършване на изпълнението на кода. Когато някоя нишка се опита да изпълни синхронизиран код, чийто обект е заключен, тя принудително изчаква отключването на този обект. Така код, синхронизиран по един и същ обект, не може да се изпълнява от две нишки едновременно и заявките за изпълнението му се изпълняват една след друга в някакъв ред.
- **Синхронизирани блокове:** Освен синхронизирането на цели методи, Java позволява синхронизация на по-ниско ниво, използвайки синхронизирани блокове. Чрез ограждане на критични секции от код със синхронизирани блокове, разработчиците могат да ограничат обхвата на синхронизацията до конкретни сегменти от кода, намалявайки потенциалните bottlenecks и подобрявайки производителността.

#### Основни принципи на конкурентното програмиране.

- **Atomicity:** Атомарността означава, че дадена операция или трябва напълно да приключи или изобщо не трябва да се започва изпълнение. При конкурентното програмиране това означава използване на заключване (locks) или други механизми за синхронизация, с цел да се гарантира че само една нишка може да борави с даден ресурс (или част от данните) в даден момент.
- **Visibility:** Видимостта означава, че чромените, направени от една нишка в споделени данни, са видими за други нишки. В Java това обикновено се постига чрез ключовата дума volatile, която казва на JVM да не кешира променливата в регистрите и винаги да я чете от основната памет.
- **Ordering:** Има глобално договорен ред, в който се извършват всички записи в споделена променлива.

#### Разпределението на ресурсите между нишки.
В многонишковата среда е от съществено значение да се осигури ефективно управление на ресурсите, за да се гарантира оптимална производителност и да се избегнат конфликти между нишките.

Основни похвати за постигането на разпределението на ресурсите са:
- **Synchronized Blocks:** Само една нишка в даден момент може да изпълни синхронизиран блок.
- **Locks:** Пакетът `java.util.concurrent.locks` предоставя експлицитни интерфейси, които могат да се ползват за заключване.
- **Atomic Variables:** Пакетът `java.util.concurrent.atomic` предоставя класове които поддържат атомарни операции върху променливи.